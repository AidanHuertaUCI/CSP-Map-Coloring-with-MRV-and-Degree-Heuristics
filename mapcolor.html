<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSP: Map Coloring with MRV and Degree Heuristic</title>
    <link rel="stylesheet" href="mapcolor.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</head>
<body>
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>

    <div class="container">
        <div class="section" id="introduction">
            <h1>CSP: Map Coloring using MRV and Degree Heuristic</h1>
            
            <h2>Introduction to Map Coloring Problems</h2>
            <p>Map coloring is a classic Constraint Satisfaction Problem (CSP) where we need to assign colors to regions of a map such that no two adjacent regions share the same color. This problem demonstrates fundamental concepts in AI search algorithms and constraint satisfaction techniques. The challenge lies in efficiently exploring the solution space while maintaining consistency constraints.</p>

            <div class="info-box">
                <strong>‚ö†Ô∏è Key Concepts:</strong><br>
                ‚Ä¢ <strong>Minimum Remaining Values (MRV):</strong> Choose the variable with the fewest legal values (most constrained variable)<br>
                ‚Ä¢ <strong>Degree Heuristic:</strong> Break ties by selecting the variable involved in the most constraints with unassigned variables<br>
                ‚Ä¢ <strong>Time Complexity:</strong> O(d^n) worst case, but heuristics significantly reduce average case<br>
                ‚Ä¢ <strong>Space Complexity:</strong> O(n) for the recursion stack, where n is the number of variables
            </div>

            <h3>Why Use Variable Selection Heuristics?</h3>
            <p>The MRV heuristic helps us fail fast by immediately detecting dead ends when a variable has no legal values. The degree heuristic reduces future branching by selecting variables that constrain the most other variables. Together, they dramatically improve search efficiency by reducing the branching factor early in the search tree.</p>

            <div class="heuristic-comparison">
                <div class="heuristic-card">
                    <h4>1Ô∏è‚É£ MRV (Most Constrained Variable)</h4>
                    <p><strong>Idea:</strong> Choose the variable with the smallest domain size</p>
                    <p><strong>Benefit:</strong> Reduces branching factor and detects failures early</p>
                    <p><strong>When to use:</strong> Primary heuristic for variable selection</p>
                </div>
                <div class="heuristic-card">
                    <h4>2Ô∏è‚É£ Degree Heuristic (Most Constraining)</h4>
                    <p><strong>Idea:</strong> Choose the variable involved in most constraints with unassigned variables</p>
                    <p><strong>Benefit:</strong> Reduces future domains of other variables</p>
                    <p><strong>When to use:</strong> As a tie-breaker when MRV produces ties</p>
                </div>
            </div>
 
            <div class="complexity-box">
                <h4>üìà Performance Analysis</h4>
                <p><strong>Without Heuristics:</strong> Random variable selection leads to high branching factors throughout the search tree.</p>
                <p><strong>With MRV + Degree:</strong> Low branching factor early on, and forward checking further reduces domains as we progress.</p>
                <p><strong>Key Insight:</strong> MRV is generally the stronger heuristic, so we prioritize it and use Degree for tie-breaking.</p>
            </div>

            <div class="algorithm-steps">
                <h4>Algorithm Overview:</h4>
                1. <strong>Variable Selection:</strong> Use MRV to select the variable with fewest legal values<br>
                2. <strong>Tie Breaking:</strong> If multiple variables have the same MRV, use Degree heuristic<br>
                3. <strong>Value Assignment:</strong> Try each value in the selected variable's domain<br>
                4. <strong>Forward Checking:</strong> Update domains of neighboring variables to maintain arc consistency<br>
                5. <strong>Recursion:</strong> Recursively solve remaining variables<br>
                6. <strong>Backtracking:</strong> If no solution exists, backtrack and try next value
            </div>
        </div>

        <div class="section" id="steps">
            <h1>Step-by-Step Algorithm Execution</h1>
            <h4>‚ùóTip: Try each step on your own. Click next to confirm your answer and see why the choice is the correct one.</h4>
            <div class="step-counter" id="stepCounter">Step 1 of 10</div>
            
            <div class="step-container">
                <h2 class="step-title" id="stepTitle">Step 1: Initial State</h2>
                
                <div style="text-align: center;">
                    <img id="stepImage" src="step1.png" alt="Step 1 visualization" class="step-image" style="display: none;">
                    <div id="imagePlaceholder" style="width: 600px; height: 400px; background: #f0f0f0; border: 2px dashed #ccc; display: inline-flex; align-items: center; justify-content: center; margin: 20px 0; border-radius: 10px;">
                        <span style="color: #666; font-size: 1.2em;">Upload Step 1 image</span>
                    </div>
                </div>
                
                <div class="step-description" id="stepDescription">
                    <strong>Step 1:</strong><br>
                </div>
            </div>

            <div class="controls">
                <button class="btn btn-secondary" id="prevBtn" onclick="previousStep()" disabled>Previous Step</button>
                <button class="btn" id="nextBtn" onclick="nextStep()">Next Step</button>
                <button class="btn btn-secondary" onclick="resetSteps()">Reset</button>
            </div>
        </div>

        <!-- Code Display  -->
        <div class="section" id="code-section">
            <h1>Algorithm Implementation</h1>
            <h2>Python Implementation</h2>
            <p>Here's how we can implement the CSP map coloring algorithm with MRV and Degree heuristics:</p>

            <div class="code-block">
            <pre><code class="language-python">def mrv_degree_csp_solver(regions, colors, neighbors):
                # Initialize domains (each region can use any color initially)
                domains = {region: colors.copy() for region in regions}
                assignment = {}
                
                def is_consistent(region, color):
                    return all(assignment.get(n) != color for n in neighbors[region])
                
                def forward_check(region, color):
                    removed = {}
                    for n in neighbors[region]:
                        if n not in assignment and color in domains[n]:
                            domains[n].remove(color)
                            removed.setdefault(n, []).append(color)
                    return removed
                
                def restore(removed):
                    for r, colors in removed.items():
                        domains[r].extend(colors)
                
                def select_variable(regions, domains, neighbors):
                    unassigned = [r for r in regions if r not in assignment]
                    if not unassigned:
                        return None
                    
                    # MRV: Find minimum remaining values
                    min_values = min(len(domains[r]) for r in unassigned)
                    mrv_vars = [r for r in unassigned if len(domains[r]) == min_values]
                    
                    # Degree heuristic: Break ties by most constraining variable
                    if len(mrv_vars) > 1:
                        max_degree = max(sum(1 for n in neighbors[r] if n not in assignment) 
                                    for r in mrv_vars)
                        return next(r for r in mrv_vars 
                                if sum(1 for n in neighbors[r] if n not in assignment) == max_degree)
                    
                    return mrv_vars[0]
                
                def backtrack():
                    if len(assignment) == len(regions):
                        return assignment
                    
                    var = select_variable(regions, domains, neighbors)
                    for color in domains[var][:]:
                        if is_consistent(var, color):
                            assignment[var] = color
                            removed = forward_check(var, color)
                            
                            result = backtrack()
                            if result:
                                return result
                            
                            del assignment[var]
                            restore(removed)
                    
                    return None
                
                return backtrack()

            </code></pre>
            </div>


            <div class="info-box">
                <strong>Key Implementation Points:</strong><br>
                ‚Ä¢ <strong>MRV Implementation:</strong> Count remaining legal values in each variable's domain<br>
                ‚Ä¢ <strong>Degree Heuristic:</strong> Count constraints with unassigned variables only<br>
                ‚Ä¢ <strong>Forward Checking:</strong> Maintain arc consistency by removing conflicting values<br>
                ‚Ä¢ <strong>Backtracking:</strong> Restore domain states when backtracking occurs<br>
                ‚Ä¢ <strong>Early Failure Detection:</strong> Stop immediately if any domain becomes empty
            </div>

            <div class="highlight">
                <strong>‚ùóPerformance Tip:</strong> The combination of MRV and Degree heuristics with forward checking typically reduces the search space by orders of magnitude compared to naive backtracking!
            </div>
        </div>
        <div class="newcontainer">
        <div class="header">
            <h1>üêç Python CSP Map Coloring Visualizer</h1>
            <p>Your Turn: Create new CSP Map Coloring Problems and see how MRV and Degree Heuristics can solve unique new problems.</p>
        </div>
        
        <div class="content">
            <div class="requirements">
                <h4>üìã Prerequisites</h4>
                <ul>
                    <li>Visual Studio Code or another IDE</li>
                    <li>Python3</li>
                    <li>matplotlib library: <code>pip install matplotlib</code></li>
                    <li>tkinter (usually included with python)</li>
                    <li>numpy library: <code>pip install numpy</code></li>
                </ul>
            </div>

            <div class="instruction-box">
                <h3>How to run the Visualizer:</h3>
                
                <div class="step">
                    <span class="step-number">1</span>
                    <strong>Download the visualizer if you have not already:</strong> Save the Python script as <code>pythonvisualizer.py</code>
                </div>
                
                <div class="step">
                    <span class="step-number">2</span>
                    <strong>Install any missing dependencies:</strong>
                    <div class="code-snippet">pip install matplotlib numpy tkinter</div>
                </div>
                    <div class="step">
                    <span class="step-number">3</span>
                    <strong>Start a python virtual enviornment</strong>
                    <div class="code-snippet">source ~/myenv/bin/activate</div>
                </div>

                <div class="step">
                    <span class="step-number">4</span>
                    <strong>Run the visualizer:</strong>
                    <div class="code-snippet">python pythonvisualizer.py</div>
                </div>
                
                <div class="step">
                    <span class="step-number">5</span>
                    <strong>Create new Map Coloring Problems:</strong> Add new regions, create edges between nodes, restrict color domains, and even change the order of the two heuristics. Try to solve the problems before having the Autocolor give the answer!
                </div>
            </div>

    </div>

    <script>
        let currentStep = 1;
        const totalSteps = 10;
        const stepDescriptions = [

            `Step 1:<br>All variables are unassigned. Every region (A‚ÄìG) starts with the domain displayed on the map. The search will begin by applying MRV.`,

            `Step 2:<br>
            <strong>Region B</strong> is selected using <strong>MRV</strong> (smallest domain) and is assigned <span style="color: blue; font-weight: bold;">Blue</span>.<br><br> 
            
            <strong>Forward checking prunes</strong> <span style="color: blue; font-weight: bold;">Blue</span> <strong>from all adjacent regions.</strong>`,

            `Step 3:<br>
             Next, <strong>Region A</strong> is selected using the <strong>Degree Heuristic</strong> as a tie breaker.<br><br>

             <strong>Region A</strong> and <strong>Region E</strong> have the <strong>same number of remaining colors</strong> (2), so the <strong>Minimum Remaining Values (MRV)</strong> heuristic results in a tie.<br><br>

             To break the tie, we apply the <strong>Degree Heuristic</strong>, which looks at how many <strong>unassigned neighbors</strong> each region has:<br><br>
             
             ‚Ä¢ <strong>Region A</strong> has <strong>4 unassigned neighbors</strong><br><br>

             ‚Ä¢ <strong>Region E</strong> has <strong>2 unassigned neighbors</strong><br><br>

             Since Region A is connected to more unassigned regions, <strong>it is more constrained</strong>, so we choose <strong>Region A.</strong><br><br>

             We assign <span style="color: red; font-weight: bold;">Red</span> to Region A and then continue with <strong>forward checking</strong> to remove invalid color options from its neighboring regions.`,

            `Step 4:<br>
             <strong>Region C</strong> is selected using the <strong>Degree Heuristic</strong> as a tie breaker.<br><br>

             <strong>Region C</strong> and <strong>Region E</strong> have the <strong>same number of remaining colors</strong> (2), so the <strong>Minimum Remaining Values (MRV)</strong> heuristic results in a tie.<br><br>

             To break the tie, we apply the <strong>Degree Heuristic</strong>, which looks at how many <strong>unassigned neighbors</strong> each region has:<br><br>
             
             ‚Ä¢ <strong>Region C</strong> has <strong>3 unassigned neighbors</strong><br><br>

             ‚Ä¢ <strong>Region E</strong> has <strong>2 unassigned neighbors</strong><br><br>

             Since Region C is connected to more unassigned regions, <strong>it is more constrained</strong>, so we choose <strong>Region C.</strong><br><br>

             We assign <span style="color: green; font-weight: bold;">Green</span> to Region C and then continue with <strong>forward checking</strong> to remove invalid color options from its neighboring regions.`,

            `Step 5:<br>

            <strong>Region E</strong> has the fewest values left (1) and is assigned <span style="color: red; font-weight: bold;">Red</span>. All adjacent regions are updated via <strong>forward checking.</strong>`,

            `Step 6:<br>
            <strong>Region F</strong> is selected next. It avoids <span style="color: red; font-weight: bold;">Red</span> and <span style="color: green; font-weight: bold;">Green</span> due to neighbors, so it is assigned <span style="color: blue; font-weight: bold;">Blue</span>.<br><br>
            
            <strong>Forward checking prunes</strong> <span style="color: blue; font-weight: bold;">Blue</span> <strong>from all adjacent regions.</strong>`,

            `Step 7:<br>
            <strong>Region D</strong> is selected using <strong>MRV</strong>. Only <span style="color: #FFD700; font-weight: bold;">Yellow</span> remains valid. <strong>Region D</strong> is assigned accordingly.<br><br>
            
            <strong>Forward checking prunes</strong> <span style="color: #FFD700; font-weight: bold;">Yellow</span> <strong>from all adjacent regions.</strong>`,

            `Step 8:<br>
            <strong>Region G</strong> is selected next. Only <span style="color: green; font-weight: bold;">Green</span> remains valid after all constraints. Assigned without conflict.`,

            `Step 9:<br>
            All variables have assignments. No domain conflicts detected. The solution is consistent with all constraints.`,

            `<strong>Complete Solution Found:</strong><br>
            <strong>Final Assignment:</strong><br>
            ‚Ä¢ A = <span style="color: red; font-weight: bold;">Red</span><br>
            ‚Ä¢ B = <span style="color: blue; font-weight: bold;">Blue</span><br>
            ‚Ä¢ C = <span style="color: green; font-weight: bold;">Green</span><br>
            ‚Ä¢ D = <span style="color: #FFD700; font-weight: bold;">Yellow</span><br>
            ‚Ä¢ E = <span style="color: red; font-weight: bold;">Red</span><br>
            ‚Ä¢ F = <span style="color: blue; font-weight: bold;">Blue</span><br>
            ‚Ä¢ G = <span style="color: green; font-weight: bold;">Green</span><br><br>
            <strong>Success!</strong> All adjacent regions have different colors.<br>
            <strong>Efficiency:</strong> No backtracking required thanks to MRV + Degree heuristics!`
        ];

        const stepTitles = [
            "Step 1: Initial State",
            "Step 2: Applying MRV after the initial state", 
            "Step 3: Degree Heuristic Tie-Breaking",
            "Step 4: Degree Heuristic Tie-Breaking Again",
            "Step 5: Applying MRV to the previous map",
            "Step 6: Continued MRV Selection",
            "Step 7: MRV Selection Continued", 
            "Step 8: Near Complete Solution",
            "Step 9: Final Variable Assignment",
            "Step 10: Complete Solution Verification"
        ];

        function updateStep() {
            document.getElementById('stepCounter').textContent = `Step ${currentStep} of ${totalSteps}`;
            
            document.getElementById('stepTitle').textContent = stepTitles[currentStep - 1];
            
            document.getElementById('stepDescription').innerHTML = stepDescriptions[currentStep - 1];
            
            const stepImage = document.getElementById('stepImage');
            const placeholder = document.getElementById('imagePlaceholder');
            
            stepImage.src = `step${currentStep}.png`;
            placeholder.innerHTML = `<span style="color: #666; font-size: 1.2em;">Upload Step ${currentStep} image</span>`;
            
            const progressFill = document.getElementById('progressFill');
            const progressPercent = (currentStep / totalSteps) * 100;
            progressFill.style.width = progressPercent + '%';
            
            document.getElementById('prevBtn').disabled = currentStep === 1;
            document.getElementById('nextBtn').disabled = currentStep === totalSteps;
            
            if (currentStep === totalSteps) {
                document.getElementById('nextBtn').textContent = 'Complete!';
            } else {
                document.getElementById('nextBtn').textContent = 'Next Step';
            }
        }

        function nextStep() {
            if (currentStep < totalSteps) {
                currentStep++;
                updateStep();
            }
        }

        function previousStep() {
            if (currentStep > 1) {
                currentStep--;
                updateStep();
            }
        }

        function resetSteps() {
            currentStep = 1;
            updateStep();
        }

        document.getElementById('stepImage').addEventListener('load', function() {
            this.style.display = 'block';
            document.getElementById('imagePlaceholder').style.display = 'none';
        });

        document.getElementById('stepImage').addEventListener('error', function() {
            this.style.display = 'none';
            document.getElementById('imagePlaceholder').style.display = 'inline-flex';
        });

        window.onload = function() {
            updateStep();
        };
    </script>
</body>

</html>
